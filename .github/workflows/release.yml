name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # Build Linux AMD64 with CGO (native OCR)
  build-linux-amd64:
    name: Build & Test Linux AMD64
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Install Tesseract dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libtesseract-dev libleptonica-dev

      - name: Download tessdata
        run: ./scripts/ensure-tessdata.sh

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Linux AMD64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            timeout 5 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | \
            grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should work with embedded tesseract)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            timeout 30 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should NOT contain "tesseract not found"
          if echo "$RESPONSE" | grep -q "tesseract not found"; then
            echo "ERROR: OCR should work on Linux with embedded tesseract"
            exit 1
          fi

      - name: Upload Linux AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-linux-amd64
          path: image-tools-mcp-v*-linux-amd64
          retention-days: 1

  # Build Linux ARM64 with CGO (native OCR)
  # Public repo has access to ARM64 runners
  build-linux-arm64:
    name: Build & Test Linux ARM64
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Install Tesseract dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libtesseract-dev libleptonica-dev

      - name: Download tessdata
        run: ./scripts/ensure-tessdata.sh

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Linux ARM64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=1 GOOS=linux GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            timeout 5 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 | \
            grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should work with embedded tesseract)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            timeout 30 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should NOT contain "tesseract not found"
          if echo "$RESPONSE" | grep -q "tesseract not found"; then
            echo "ERROR: OCR should work on Linux with embedded tesseract"
            exit 1
          fi

      - name: Upload Linux ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-linux-arm64
          path: image-tools-mcp-v*-linux-arm64
          retention-days: 1

  # Build and test macOS AMD64
  build-darwin-amd64:
    name: Build & Test macOS AMD64
    runs-on: macos-15-large  # Intel Mac (macos-13 retired, using macos-15-large for Intel)
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build macOS AMD64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          # Use perl for timeout on macOS (no gtimeout/timeout available)
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            perl -e 'alarm 10; exec @ARGV' ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 | \
            head -100 | grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should return install instructions)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should contain "tesseract not found" or "brew install"
          if echo "$RESPONSE" | grep -qE "tesseract not found|brew install"; then
            echo "OK: OCR correctly reports tesseract not installed"
          else
            echo "ERROR: OCR should report tesseract not found on macOS without tesseract"
            exit 1
          fi

      - name: Upload macOS AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-amd64
          path: image-tools-mcp-v*-darwin-amd64
          retention-days: 1

  # Build and test macOS ARM64
  build-darwin-arm64:
    name: Build & Test macOS ARM64
    runs-on: macos-latest  # ARM64 Mac
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build macOS ARM64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          # Use perl for timeout on macOS (no gtimeout/timeout available)
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            perl -e 'alarm 10; exec @ARGV' ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 | \
            head -100 | grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should return install instructions)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should contain "tesseract not found" or "brew install"
          if echo "$RESPONSE" | grep -qE "tesseract not found|brew install"; then
            echo "OK: OCR correctly reports tesseract not installed"
          else
            echo "ERROR: OCR should report tesseract not found on macOS without tesseract"
            exit 1
          fi

      - name: Upload macOS ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-arm64
          path: image-tools-mcp-v*-darwin-arm64
          retention-days: 1

  # Build and test Windows AMD64
  build-windows-amd64:
    name: Build & Test Windows AMD64
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        shell: bash
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Windows AMD64 binary
        shell: bash
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        shell: pwsh
        run: |
          $output = & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe" --version 2>&1 | Out-String
          Write-Host "Version output: $output"
          if ($output -notlike "*${{ steps.version.outputs.VERSION }}*") {
            throw "Version mismatch: expected ${{ steps.version.outputs.VERSION }} in output"
          }

      - name: Smoke test - MCP tools/list
        shell: pwsh
        run: |
          $response = '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe"
          Write-Host $response
          if ($response -notmatch "image_load") {
            throw "tools/list failed"
          }

      - name: Smoke test - Image operations
        shell: pwsh
        run: |
          $testImage = (Get-Location).Path + "/testdata/simple_diagram.png"
          $testImage = $testImage -replace '\\', '/'

          # Test image_load
          $json = '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"image_load","arguments":{"path":"' + $testImage + '"}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") | Out-String
          Write-Host "image_load response: $response"
          if ($response -notmatch 'width') {
            throw "image_load failed - width not found in response"
          }

          # Test image_sample_color
          $json = '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"image_sample_color","arguments":{"path":"' + $testImage + '","x":10,"y":10}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") | Out-String
          Write-Host "image_sample_color response: $response"
          if ($response -notmatch 'hex') {
            throw "image_sample_color failed - hex not found in response"
          }

      - name: Smoke test - OCR (should return install instructions)
        shell: pwsh
        run: |
          $testImage = (Get-Location).Path + "/testdata/simple_diagram.png"
          $testImage = $testImage -replace '\\', '/'
          $json = '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"image_ocr_full","arguments":{"path":"' + $testImage + '","language":"eng"}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") | Out-String
          Write-Host "OCR response: $response"
          if ($response -match "tesseract not found" -or $response -match "UB-Mannheim") {
            Write-Host "OK: OCR correctly reports tesseract not installed"
          } else {
            throw "OCR should report tesseract not found on Windows without tesseract"
          }

      - name: Upload Windows AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-windows-amd64
          path: image-tools-mcp-v*-windows-amd64.exe
          retention-days: 1

  # Build and test Windows ARM64
  build-windows-arm64:
    name: Build & Test Windows ARM64
    runs-on: windows-latest  # Cross-compile, can't run native tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        shell: bash
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Windows ARM64 binary
        shell: bash
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=windows GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe" \
            ./cmd/image-mcp

      - name: Verify binary was created
        shell: pwsh
        run: |
          if (!(Test-Path "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe")) {
            throw "Binary was not created"
          }
          $size = (Get-Item "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe").Length
          Write-Host "Binary size: $size bytes"
          if ($size -lt 1000000) {
            throw "Binary seems too small"
          }

      # Note: Cannot run ARM64 binary on AMD64 runner
      # The binary will be tested by the user on actual ARM64 Windows

      - name: Upload Windows ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-windows-arm64
          path: image-tools-mcp-v*-windows-arm64.exe
          retention-days: 1

  # Assemble container-tools package (only after all builds pass)
  # Follows Container Tools MCP Integration Guide specification
  assemble-package:
    name: Assemble Container Tools Package
    runs-on: ubuntu-latest
    needs:
      - build-linux-amd64
      - build-linux-arm64
      - build-darwin-amd64
      - build-darwin-arm64
      - build-windows-amd64
      - build-windows-arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Download all binaries
        uses: actions/download-artifact@v4
        with:
          path: binaries/
          pattern: binary-*
          merge-multiple: true

      - name: List downloaded binaries
        run: ls -la binaries/

      - name: Create container-tools package structure
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          # Package naming per Integration Guide
          PACKAGE_NAME="container-tools-image-tools-mcp-v${VERSION}"
          MCP_NAME="image-tools-mcp"

          # Directory structure per Integration Guide:
          #   package-name/
          #   ├── image-tools-mcp/        # MCP's territory (all content here)
          #   │   ├── bin/
          #   │   │   ├── image-tools-mcp (launcher)
          #   │   │   └── platforms/
          #   │   ├── install.sh          # Installer lives inside MCP folder
          #   │   ├── LICENSE
          #   │   ├── CHANGELOG.md
          #   │   ├── README.md
          #   │   └── VERSION_MANIFEST.txt
          #   └── etc/
          #       ├── hooks-dispatcher.sh
          #       └── hooks.d/
          #           └── app-start/
          #               └── image-tools-mcp.sh

          mkdir -p "${PACKAGE_NAME}/${MCP_NAME}/bin/platforms"
          mkdir -p "${PACKAGE_NAME}/etc/hooks.d/app-start"

          # Copy all binaries to platforms directory
          cp binaries/* "${PACKAGE_NAME}/${MCP_NAME}/bin/platforms/"
          chmod +x "${PACKAGE_NAME}/${MCP_NAME}/bin/platforms"/*

          # Copy LICENSE and CHANGELOG
          cp LICENSE "${PACKAGE_NAME}/${MCP_NAME}/"
          cp CHANGELOG.md "${PACKAGE_NAME}/${MCP_NAME}/"

          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV

      - name: Create universal launcher
        env:
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          MCP_NAME="image-tools-mcp"
          LAUNCHER_FILE="${PACKAGE_NAME}/${MCP_NAME}/bin/${MCP_NAME}"

          # Write launcher script (using quoted heredoc to preserve content)
          cat > "$LAUNCHER_FILE" << 'LAUNCHEREOF'
          #!/usr/bin/env bash
          #
          # Universal launcher for image-tools-mcp
          # Auto-detects OS, architecture, and container environment
          #
          set -e

          LAUNCHER_VERSION="__VERSION__"
          MCP_NAME="image-tools-mcp"

          # Resolve the real path of this script, following symlinks
          # This is needed when the launcher is invoked via /opt/container-tools/bin/ symlink
          resolve_script_path() {
              local script="${BASH_SOURCE[0]}"
              while [ -L "$script" ]; do
                  local script_dir="$(cd "$(dirname "$script")" && pwd)"
                  script="$(readlink "$script")"
                  # If relative symlink, resolve it relative to the symlink's directory
                  [[ "$script" != /* ]] && script="$script_dir/$script"
              done
              cd "$(dirname "$script")" && pwd
          }

          BIN_DIR="$(resolve_script_path)"
          PLATFORMS_DIR="${BIN_DIR}/platforms"

          # Debug mode
          debug() {
              if [ -n "${IMAGE_TOOLS_MCP_DEBUG}" ]; then
                  echo "[DEBUG] $*" >&2
              fi
          }

          # Container detection
          is_container() {
              [ -f /.dockerenv ] && return 0
              [ -n "${CONTAINER}" ] && return 0
              [ -f /proc/1/cgroup ] && grep -qE 'docker|containerd|podman|kubernetes' /proc/1/cgroup 2>/dev/null && return 0
              return 1
          }

          # Architecture detection
          detect_arch() {
              case "$(uname -m)" in
                  x86_64|amd64) echo "amd64" ;;
                  aarch64|arm64) echo "arm64" ;;
                  *) echo "unknown" ;;
              esac
          }

          # OS detection
          detect_os() {
              case "$(uname -s | tr '[:upper:]' '[:lower:]')" in
                  darwin) echo "darwin" ;;
                  linux) echo "linux" ;;
                  mingw*|msys*|cygwin*) echo "windows" ;;
                  *) echo "unknown" ;;
              esac
          }

          # Binary selection
          select_binary() {
              local os=$(detect_os)
              local arch=$(detect_arch)
              local suffix=""

              # Always use Linux binary in containers
              if is_container; then
                  debug "Container detected, using Linux binary"
                  os="linux"
              fi

              if [ "$os" = "windows" ]; then
                  suffix=".exe"
              fi

              local binary="${PLATFORMS_DIR}/${MCP_NAME}-v${LAUNCHER_VERSION}-${os}-${arch}${suffix}"

              debug "OS: ${os}, Arch: ${arch}, Container: $(is_container && echo yes || echo no)"
              debug "Selected binary: ${binary}"

              if [ ! -f "$binary" ]; then
                  echo "ERROR: Binary not found: ${binary}" >&2
                  echo "Available binaries:" >&2
                  ls -1 "${PLATFORMS_DIR}/" >&2
                  exit 1
              fi

              echo "$binary"
          }

          # Execute
          exec "$(select_binary)" "$@"
          LAUNCHEREOF

          # Strip the leading indentation (10 spaces) that YAML required
          sed -i 's/^          //' "$LAUNCHER_FILE"
          sed -i "s/__VERSION__/${VERSION}/g" "$LAUNCHER_FILE"
          chmod +x "$LAUNCHER_FILE"

      - name: Create hooks-dispatcher.sh
        run: |
          # Per Integration Guide Section 3
          DISPATCHER_FILE="${PACKAGE_NAME}/etc/hooks-dispatcher.sh"
          cat > "$DISPATCHER_FILE" << 'DISPATCHEREOF'
          #!/bin/bash
          #
          # Container Tools Hook Dispatcher
          # Runs all hook scripts for a given hook type
          #
          # Usage: hooks-dispatcher.sh <hook-type>
          # Example: hooks-dispatcher.sh app-start
          #

          set -e

          HOOK_TYPE="$1"
          HOOKS_DIR="/opt/container-tools/etc/hooks.d/${HOOK_TYPE}"

          if [ -z "$HOOK_TYPE" ]; then
              echo "Usage: $0 <hook-type>" >&2
              exit 1
          fi

          if [ ! -d "$HOOKS_DIR" ]; then
              # No hooks registered for this type - that's okay
              exit 0
          fi

          # Run all executable scripts in alphabetical order
          for script in "$HOOKS_DIR"/*.sh; do
              if [ -f "$script" ] && [ -x "$script" ]; then
                  if [ -n "$CONTAINER_TOOLS_DEBUG" ]; then
                      echo "[hooks-dispatcher] Running: $script" >&2
                  fi

                  # Run hook, capture errors but don't stop other hooks
                  if ! "$script"; then
                      echo "[hooks-dispatcher] Warning: $script failed" >&2
                  fi
              fi
          done

          exit 0
          DISPATCHEREOF
          sed -i 's/^          //' "$DISPATCHER_FILE"
          chmod +x "$DISPATCHER_FILE"

      - name: Create app-start hook
        run: |
          MCP_NAME="image-tools-mcp"
          HOOK_FILE="${PACKAGE_NAME}/etc/hooks.d/app-start/${MCP_NAME}.sh"

          cat > "$HOOK_FILE" << 'HOOKEOF'
          #!/bin/bash
          #
          # image-tools-mcp app-start hook
          # Called when Claude Code starts
          #
          # This hook can be used for:
          # - Verifying dependencies are available
          # - Initializing cache directories
          # - Logging startup events
          #

          # Currently a placeholder - image-tools-mcp doesn't require initialization
          # but having the hook in place follows the container-tools pattern

          if [ -n "$CONTAINER_TOOLS_DEBUG" ]; then
              echo "[image-tools-mcp] App start hook executed" >&2
          fi

          exit 0
          HOOKEOF
          sed -i 's/^          //' "$HOOK_FILE"
          chmod +x "$HOOK_FILE"

      - name: Create install script
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          MCP_NAME="image-tools-mcp"
          INSTALL_FILE="${PACKAGE_NAME}/${MCP_NAME}/install.sh"

          # Per Integration Guide Section 8 - Full installer template
          # Content is indented for YAML, will strip leading spaces
          cat > "$INSTALL_FILE" << 'INSTALLEOF'
          #!/bin/bash
          #
          # image-tools-mcp installer for container-tools
          #
          # Usage:
          #   ./install.sh [OPTIONS] [target-dir]
          #
          # Options:
          #   --target DIR    Install to DIR (default: /opt/container-tools)
          #   --uninstall     Remove/rollback image-tools-mcp from container-tools
          #   --help          Show this help
          #
          # Default target: /opt/container-tools
          #

          set -e

          YOUR_MCP="image-tools-mcp"
          VERSION="__VERSION__"

          # Colors
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          RED='\033[0;31m'
          BLUE='\033[0;34m'
          NC='\033[0m'

          info() { echo -e "${GREEN}[INFO]${NC} $1"; }
          warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
          error() { echo -e "${RED}[ERROR]${NC} $1"; exit 1; }

          # Parse arguments
          UNINSTALL=false
          TARGET="/opt/container-tools"

          while [[ $# -gt 0 ]]; do
              case $1 in
                  --uninstall)
                      UNINSTALL=true
                      shift
                      ;;
                  --target)
                      TARGET="$2"
                      shift 2
                      ;;
                  --help|-h)
                      head -20 "$0" | tail -15
                      exit 0
                      ;;
                  *)
                      TARGET="$1"
                      shift
                      ;;
              esac
          done

          # Check for sudo if needed
          need_sudo() {
              if [ -w "$TARGET" ] 2>/dev/null || [ -w "$(dirname "$TARGET")" ] 2>/dev/null; then
                  echo ""
              else
                  echo "sudo"
              fi
          }
          SUDO=$(need_sudo)

          # Get script directory (install.sh is inside the MCP folder)
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          # Package root is parent of MCP folder (contains etc/)
          PACKAGE_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

          #
          # PLATFORM DETECTION
          #
          detect_platform() {
              local os=$(uname -s | tr '[:upper:]' '[:lower:]')
              local arch=$(uname -m)
              case "$arch" in
                  x86_64|amd64) arch="amd64" ;;
                  aarch64|arm64) arch="arm64" ;;
                  *) arch="unknown" ;;
              esac
              echo "${os}-${arch}"
          }

          #
          # UNINSTALL / ROLLBACK
          #
          if [ "$UNINSTALL" = true ]; then
              info "Uninstalling $YOUR_MCP from $TARGET..."

              # Check if we have a prior installation to roll back to
              if [ -d "$TARGET/$YOUR_MCP/backup/prior" ]; then
                  info "Prior installation found - performing rollback..."

                  # 1. Save current backup/prior to temp
                  $SUDO mv "$TARGET/$YOUR_MCP/backup/prior" "/tmp/$YOUR_MCP-prior-$$"

                  # 2. Remove current installation
                  $SUDO rm -rf "$TARGET/$YOUR_MCP"

                  # 3. Restore prior installation from temp
                  $SUDO mv "/tmp/$YOUR_MCP-prior-$$" "$TARGET/$YOUR_MCP"
                  info "Restored prior installation"

                  # 3. Rollback mcp.json entry (merge prior entry into current mcp.json)
                  PRIOR_MCP_JSON="$TARGET/$YOUR_MCP/backup/mcp.json-prior"
                  CURRENT_MCP_JSON="$TARGET/etc/mcp.json"

                  if [ -f "$PRIOR_MCP_JSON" ] && command -v jq &> /dev/null; then
                      # Extract our entry from the prior mcp.json
                      PRIOR_ENTRY=$($SUDO cat "$PRIOR_MCP_JSON" | jq ".mcpServers[\"$YOUR_MCP\"]")

                      if [ "$PRIOR_ENTRY" != "null" ]; then
                          # Merge prior entry into current mcp.json (preserves other MCPs)
                          $SUDO jq --argjson entry "$PRIOR_ENTRY" \
                             ".mcpServers[\"$YOUR_MCP\"] = \$entry" \
                             "$CURRENT_MCP_JSON" > "/tmp/mcp.json.tmp"
                          $SUDO mv "/tmp/mcp.json.tmp" "$CURRENT_MCP_JSON"
                          info "Rolled back mcp.json entry to prior version"
                      fi
                  else
                      warn "Could not rollback mcp.json entry (jq not found or no prior backup)"
                  fi

                  # 4. Update symlink to point to restored version
                  case "$OSTYPE" in
                      msys*|cygwin*|win32*) ;;
                      *)
                          $SUDO rm -f "$TARGET/bin/$YOUR_MCP"
                          $SUDO ln -sf "../$YOUR_MCP/bin/$YOUR_MCP" "$TARGET/bin/$YOUR_MCP"
                          ;;
                  esac

                  info "Rollback complete - restored prior version"
              else
                  info "No prior installation - performing full removal..."

                  # Remove our directory
                  $SUDO rm -rf "$TARGET/$YOUR_MCP"

                  # Remove our symlink
                  $SUDO rm -f "$TARGET/bin/$YOUR_MCP"

                  # Remove our hooks
                  $SUDO find "$TARGET/etc/hooks.d" -name "$YOUR_MCP.sh" -delete 2>/dev/null || true

                  # Remove our entry from mcp.json
                  if command -v jq &> /dev/null && [ -f "$TARGET/etc/mcp.json" ]; then
                      $SUDO jq "del(.mcpServers[\"$YOUR_MCP\"])" \
                         "$TARGET/etc/mcp.json" > "/tmp/mcp.json.tmp"
                      $SUDO mv "/tmp/mcp.json.tmp" "$TARGET/etc/mcp.json"
                      info "Removed $YOUR_MCP from mcp.json"
                  else
                      warn "Please manually remove '$YOUR_MCP' from $TARGET/etc/mcp.json"
                  fi

                  info "Uninstall complete"
              fi
              exit 0
          fi

          #
          # INSTALL
          #

          # Check if already up to date (skip-if-identical optimization)
          PLATFORM=$(detect_platform)
          SOURCE_BIN=$(find "$SCRIPT_DIR/$YOUR_MCP/bin/platforms" -name "*-${PLATFORM}" -o -name "*-${PLATFORM}.exe" 2>/dev/null | head -1)
          DEST_BIN=$(find "$TARGET/$YOUR_MCP/bin/platforms" -name "*-${PLATFORM}" -o -name "*-${PLATFORM}.exe" 2>/dev/null | head -1)

          if [ -n "$SOURCE_BIN" ] && [ -n "$DEST_BIN" ]; then
              SOURCE_MD5=$(md5sum "$SOURCE_BIN" 2>/dev/null | awk '{print $1}')
              DEST_MD5=$(md5sum "$DEST_BIN" 2>/dev/null | awk '{print $1}')
              if [ -n "$SOURCE_MD5" ] && [ "$SOURCE_MD5" = "$DEST_MD5" ]; then
                  info "Already up to date (${PLATFORM} binary unchanged)"
                  exit 0
              fi
          fi

          echo ""
          echo "========================================="
          echo -e "${BLUE}Installing $YOUR_MCP v${VERSION}${NC}"
          echo "========================================="
          echo ""
          info "Target: $TARGET"

          # 1. Create directory structure if first-time install
          if [ ! -d "$TARGET" ]; then
              info "Creating container-tools directory structure..."
              $SUDO mkdir -p "$TARGET/bin"
              $SUDO mkdir -p "$TARGET/etc/hooks.d/app-start"
              $SUDO mkdir -p "$TARGET/etc/hooks.d/compact-start"
              $SUDO mkdir -p "$TARGET/etc/hooks.d/compact-end"
          fi

          # Ensure subdirectories exist
          $SUDO mkdir -p "$TARGET/bin"
          $SUDO mkdir -p "$TARGET/etc/hooks.d/app-start"

          # 2. Backup existing mcp.json to our territory
          if [ -f "$TARGET/etc/mcp.json" ]; then
              $SUDO mkdir -p "$TARGET/$YOUR_MCP/backup"
              $SUDO cp "$TARGET/etc/mcp.json" "$TARGET/$YOUR_MCP/backup/mcp.json-prior"
              info "Backed up mcp.json to $YOUR_MCP/backup/"
          fi

          # 3. Backup existing installation to backup/prior/ (depth of 1)
          if [ -d "$TARGET/$YOUR_MCP" ]; then
              info "Backing up previous installation..."
              # Move existing installation to temp
              $SUDO mv "$TARGET/$YOUR_MCP" "/tmp/$YOUR_MCP-backup-$$"
          fi

          # 4. Install MCP directory (from SCRIPT_DIR which is the MCP folder in the package)
          info "Installing $YOUR_MCP..."
          $SUDO cp -r "$SCRIPT_DIR" "$TARGET/$YOUR_MCP"

          # 5. Move prior installation into backup/prior/ if it existed
          if [ -d "/tmp/$YOUR_MCP-backup-$$" ]; then
              $SUDO mkdir -p "$TARGET/$YOUR_MCP/backup"
              $SUDO rm -rf "$TARGET/$YOUR_MCP/backup/prior"
              $SUDO mv "/tmp/$YOUR_MCP-backup-$$" "$TARGET/$YOUR_MCP/backup/prior"
              info "Prior installation saved to $YOUR_MCP/backup/prior/"
          fi

          # Ensure binaries are executable
          $SUDO chmod +x "$TARGET/$YOUR_MCP/bin/$YOUR_MCP"
          $SUDO chmod +x "$TARGET/$YOUR_MCP/bin/platforms"/* 2>/dev/null || true

          # 6. Install hooks dispatcher if missing
          if [ ! -f "$TARGET/etc/hooks-dispatcher.sh" ]; then
              info "Installing hooks dispatcher..."
              $SUDO cp "$PACKAGE_ROOT/etc/hooks-dispatcher.sh" "$TARGET/etc/"
              $SUDO chmod +x "$TARGET/etc/hooks-dispatcher.sh"
          fi

          # 7. Install our hooks
          info "Installing hooks..."
          if [ -f "$PACKAGE_ROOT/etc/hooks.d/app-start/$YOUR_MCP.sh" ]; then
              $SUDO cp "$PACKAGE_ROOT/etc/hooks.d/app-start/$YOUR_MCP.sh" "$TARGET/etc/hooks.d/app-start/"
              $SUDO chmod +x "$TARGET/etc/hooks.d/app-start/$YOUR_MCP.sh"
          fi

          # 7. Create symlink (Linux/macOS only)
          case "$OSTYPE" in
              msys*|cygwin*|win32*)
                  warn "Windows detected - skipping symlink"
                  warn "Add $TARGET/$YOUR_MCP/bin to your PATH"
                  ;;
              *)
                  $SUDO ln -sf "../$YOUR_MCP/bin/$YOUR_MCP" "$TARGET/bin/$YOUR_MCP"
                  info "Created symlink: $TARGET/bin/$YOUR_MCP"
                  ;;
          esac

          # 9. Update mcp.json
          MCP_JSON="$TARGET/etc/mcp.json"
          YOUR_COMMAND="$TARGET/$YOUR_MCP/bin/$YOUR_MCP"
          DISPATCHER="$TARGET/etc/hooks-dispatcher.sh"

          if [ ! -f "$MCP_JSON" ]; then
              info "Creating mcp.json..."
              $SUDO tee "$MCP_JSON" > /dev/null << MCPEOF
          {
            "mcpServers": {
              "$YOUR_MCP": {
                "command": "$YOUR_COMMAND",
                "args": ["--mode", "stdio"]
              }
            },
            "hooks": {
              "app-start": "$DISPATCHER app-start",
              "compact-start": "$DISPATCHER compact-start",
              "compact-end": "$DISPATCHER compact-end"
            }
          }
          MCPEOF
          elif command -v jq &> /dev/null; then
              info "Merging into mcp.json..."
              $SUDO jq --arg name "$YOUR_MCP" \
                 --arg cmd "$YOUR_COMMAND" \
                 --arg dispatcher "$DISPATCHER" \
                 '.mcpServers[$name] = {"command": $cmd, "args": ["--mode", "stdio"]} |
                  .hooks["app-start"] = "\($dispatcher) app-start" |
                  .hooks["compact-start"] = "\($dispatcher) compact-start" |
                  .hooks["compact-end"] = "\($dispatcher) compact-end"' \
                 "$MCP_JSON" > "/tmp/mcp.json.tmp"
              $SUDO mv "/tmp/mcp.json.tmp" "$MCP_JSON"
          else
              warn "jq not found - please manually configure mcp.json"
              warn "Add $YOUR_MCP entry with args: [\"--mode\", \"stdio\"]"
          fi

          # 9. Verify installation
          echo ""
          info "Verifying installation..."
          if [ -x "$TARGET/$YOUR_MCP/bin/$YOUR_MCP" ]; then
              VERSION_OUTPUT=$("$TARGET/$YOUR_MCP/bin/$YOUR_MCP" --version 2>&1 | head -1)
              info "Installed: $VERSION_OUTPUT"
          else
              error "Installation verification failed - launcher not executable"
          fi

          # Summary
          echo ""
          echo "========================================="
          echo -e "${GREEN}Installation complete!${NC}"
          echo "========================================="
          echo ""
          echo "Installed to: $TARGET/$YOUR_MCP/"
          echo ""
          echo -e "${BLUE}Next steps:${NC}"
          case "$OSTYPE" in
              msys*|cygwin*|win32*)
                  echo "  1. Add $TARGET/$YOUR_MCP/bin to your PATH"
                  ;;
              *)
                  echo "  1. Add $TARGET/bin to your PATH (if not already)"
                  ;;
          esac
          echo "  2. Restart Claude Code to load the new MCP"
          echo ""
          echo -e "${BLUE}Test:${NC}"
          echo "  $TARGET/$YOUR_MCP/bin/$YOUR_MCP --version"
          echo ""
          echo -e "${BLUE}Rollback (if needed):${NC}"
          echo "  ./install.sh --uninstall"
          echo ""
          INSTALLEOF

          sed -i 's/^          //' "$INSTALL_FILE"
          sed -i "s/__VERSION__/${VERSION}/g" "$INSTALL_FILE"
          chmod +x "$INSTALL_FILE"

      - name: Create README and manifest
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          MCP_NAME="image-tools-mcp"
          README_FILE="${PACKAGE_NAME}/${MCP_NAME}/README.md"
          MANIFEST_FILE="${PACKAGE_NAME}/${MCP_NAME}/VERSION_MANIFEST.txt"

          cat > "$README_FILE" << READMEEOF
          # Image Tools MCP v${VERSION}

          MCP server providing image analysis tools for Claude.

          ## Features

          - Image loading and metadata extraction
          - Color sampling (single point and multi-point)
          - Dominant color extraction
          - Image cropping (coordinates and named regions)
          - Distance measurement
          - Grid overlay generation
          - Edge detection
          - Shape detection (rectangles, circles, lines)
          - Text region detection
          - OCR (built-in on Linux; macOS/Windows require Tesseract CLI)

          ## Installation

          Run the installer from the extracted package:

          \`\`\`bash
          ./image-tools-mcp/install.sh
          \`\`\`

          Or specify a custom target:

          \`\`\`bash
          ./image-tools-mcp/install.sh --target /custom/path
          \`\`\`

          ## Usage

          After installation, the universal launcher is available at:

          \`\`\`bash
          /opt/container-tools/image-tools-mcp/bin/image-tools-mcp --version
          \`\`\`

          Or via the symlink:

          \`\`\`bash
          /opt/container-tools/bin/image-tools-mcp --version
          \`\`\`

          ## MCP Configuration

          The installer automatically configures \`/opt/container-tools/etc/mcp.json\`.

          Manual configuration (if needed):

          \`\`\`json
          {
            "mcpServers": {
              "image-tools-mcp": {
                "command": "/opt/container-tools/image-tools-mcp/bin/image-tools-mcp",
                "args": []
              }
            }
          }
          \`\`\`

          ## Uninstall / Rollback

          To uninstall or rollback to a prior version:

          \`\`\`bash
          ./image-tools-mcp/install.sh --uninstall
          \`\`\`

          If a prior installation exists, it will be restored. Otherwise, the MCP is fully removed.

          ## Build Info

          - Version: ${VERSION}
          - Git Commit: $(git rev-parse --short HEAD)
          - Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          READMEEOF
          sed -i 's/^          //' "$README_FILE"

          cat > "$MANIFEST_FILE" << MANIFESTEOF
          Package: ${MCP_NAME}
          Version: ${VERSION}
          Git Commit: $(git rev-parse --short HEAD)
          Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          Directory Structure:
            ${MCP_NAME}/           - MCP installation directory
            ${MCP_NAME}/bin/       - Universal launcher and platform binaries
            etc/                   - Shared configuration (hooks dispatcher)

          Platforms:
            - linux-amd64 (CGO, embedded OCR)
            - linux-arm64 (CGO, embedded OCR)
            - darwin-amd64 (CLI fallback for OCR)
            - darwin-arm64 (CLI fallback for OCR)
            - windows-amd64 (CLI fallback for OCR)
            - windows-arm64 (CLI fallback for OCR)

          Container Tools Integration Guide Compliant: Yes
          MANIFESTEOF
          sed -i 's/^          //' "$MANIFEST_FILE"

      - name: Create tarball
        run: |
          tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}"

      - name: Upload container-tools package
        uses: actions/upload-artifact@v4
        with:
          name: container-tools-package
          path: container-tools-image-tools-mcp-v*.tar.gz
          retention-days: 1

  # Sign macOS binaries (optional)
  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: [build-darwin-amd64, build-darwin-arm64, assemble-package]
    if: ${{ vars.MACOS_SIGNING_ENABLED == 'true' }}
    steps:
      - name: Download darwin-amd64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-darwin-amd64
          path: binaries/

      - name: Download darwin-arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-darwin-arm64
          path: binaries/

      - name: Download container-tools package
        uses: actions/download-artifact@v4
        with:
          name: container-tools-package
          path: package/

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          KEYCHAIN_PWD: ${{ secrets.KEYCHAIN_PWD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          echo -n "$MACOS_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH

          security create-keychain -p "$KEYCHAIN_PWD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PWD" $KEYCHAIN_PATH

          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PWD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Sign macOS binaries
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          for binary in binaries/*darwin*; do
            echo "Signing $binary..."
            codesign --force --options runtime \
              --sign "Developer ID Application: ${{ secrets.APPLE_DEVELOPER_NAME }} ($APPLE_TEAM_ID)" \
              --timestamp \
              "$binary"
            codesign --verify --verbose "$binary"
          done

      - name: Notarize binaries
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cd binaries
          for binary in *darwin*; do
            echo "Notarizing $binary..."
            zip "${binary}.zip" "$binary"
            xcrun notarytool submit "${binary}.zip" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_ID_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait
            # Note: stapler doesn't work on standalone binaries, only on .app/.pkg/.dmg
            # Notarization alone is sufficient - Apple records the notarization and
            # Gatekeeper will check it online when the binary is first run
            rm "${binary}.zip"
          done

      - name: Rebuild container-tools package with signed binaries
        run: |
          cd package
          tar -xzf *.tar.gz
          rm *.tar.gz
          PACKAGE_DIR=$(ls -d */ | head -1)
          # Correct path per Integration Guide: {mcp-name}/bin/platforms/ (no extra opt/)
          cp ../binaries/*darwin* "${PACKAGE_DIR}/image-tools-mcp/bin/platforms/"
          tar -czf "${PACKAGE_DIR%/}.tar.gz" "$PACKAGE_DIR"

      - name: Upload signed darwin-amd64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-amd64-signed
          path: binaries/*darwin-amd64*

      - name: Upload signed darwin-arm64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-arm64-signed
          path: binaries/*darwin-arm64*

      - name: Upload signed container-tools package
        uses: actions/upload-artifact@v4
        with:
          name: container-tools-package-signed
          path: package/*.tar.gz

  # Create GitHub Release (only after all builds, tests, and optional signing pass)
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [assemble-package, sign-macos]
    if: ${{ always() && needs.assemble-package.result == 'success' && (needs.sign-macos.result == 'success' || needs.sign-macos.result == 'skipped') }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      # Download all individual platform binaries
      - name: Download linux-amd64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-linux-amd64
          path: binaries/

      - name: Download linux-arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-linux-arm64
          path: binaries/

      - name: Download darwin-amd64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-darwin-amd64
          path: binaries/

      - name: Download darwin-arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-darwin-arm64
          path: binaries/

      - name: Download windows-amd64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-windows-amd64
          path: binaries/

      - name: Download windows-arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: binary-windows-arm64
          path: binaries/

      # Download container-tools package (unsigned)
      - name: Download container-tools package
        uses: actions/download-artifact@v4
        with:
          name: container-tools-package
          path: packages/

      # Download signed artifacts if available
      - name: Download signed darwin-amd64 binary (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: binary-darwin-amd64-signed
          path: binaries-signed/

      - name: Download signed darwin-arm64 binary (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: binary-darwin-arm64-signed
          path: binaries-signed/

      - name: Download signed container-tools package (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: container-tools-package-signed
          path: packages-signed/

      - name: Use signed artifacts if available
        run: |
          # Check if signed container-tools package exists
          if [ -d "packages-signed" ] && [ "$(ls -A packages-signed 2>/dev/null)" ]; then
            echo "Using signed container-tools package"
            rm -rf packages/*
            mv packages-signed/* packages/
            echo "SIGNED=true" >> $GITHUB_ENV
          else
            echo "Using unsigned container-tools package"
            echo "SIGNED=false" >> $GITHUB_ENV
          fi

          # Replace darwin binaries with signed versions if available
          if [ -d "binaries-signed" ] && [ "$(ls -A binaries-signed 2>/dev/null)" ]; then
            echo "Using signed darwin binaries"
            for signed in binaries-signed/*; do
              if [ -f "$signed" ]; then
                echo "  Replacing with signed: $(basename $signed)"
                cp "$signed" binaries/
              fi
            done
          fi

      - name: Create individual binary archives
        run: |
          mkdir -p release
          cd binaries
          for binary in *; do
            if [[ "$binary" == *.exe ]]; then
              # Windows: create .zip
              zip "../release/${binary%.exe}.zip" "$binary"
            else
              # Linux/macOS: create .tar.gz
              tar -czf "../release/${binary}.tar.gz" "$binary"
            fi
          done
          # Move container-tools package to release
          mv ../packages/*.tar.gz ../release/

      - name: List release artifacts
        run: |
          echo "Release artifacts:"
          ls -la release/

      - name: Generate checksums
        run: |
          cd release
          sha256sum * > checksums.txt
          echo ""
          echo "Checksums:"
          cat checksums.txt

      - name: Check if signed
        id: check-signed
        run: |
          if [ "$SIGNED" = "true" ]; then
            echo "MACOS_NOTE=macOS binaries are signed and notarized." >> $GITHUB_OUTPUT
          else
            echo "MACOS_NOTE=macOS binaries are unsigned. Run \`xattr -d com.apple.quarantine <binary>\` after download." >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Release ${{ steps.version.outputs.VERSION }}
          draft: false
          prerelease: false
          files: |
            release/*
          body: |
            ## Image Tools MCP ${{ steps.version.outputs.VERSION }}

            MCP server providing image analysis tools for Claude.

            ### OCR Support
            - **Linux (AMD64 & ARM64)**: Built-in OCR with embedded Tesseract - no installation required
            - **macOS & Windows**: Requires Tesseract CLI installation (`brew install tesseract` or download from GitHub)

            ---

            ### Option 1: Container-Tools Package (Recommended)

            Best for users with `/opt/container-tools/` setup (works alongside todo-mcp, etc.)

            ```bash
            # Download and extract
            tar -xzf container-tools-image-tools-mcp-${{ steps.version.outputs.VERSION }}.tar.gz
            cd container-tools-image-tools-mcp-${{ steps.version.outputs.VERSION }}

            # Install (creates or merges into /opt/container-tools/)
            ./image-tools-mcp/install.sh

            # Verify
            /opt/container-tools/image-tools-mcp/bin/image-tools-mcp --version
            ```

            ---

            ### Option 2: Standalone Binary

            Download a single binary for your platform:

            | Platform | File | OCR |
            |----------|------|-----|
            | Linux AMD64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-linux-amd64.tar.gz` | Built-in |
            | Linux ARM64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-linux-arm64.tar.gz` | Built-in |
            | macOS Apple Silicon | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-darwin-arm64.tar.gz` | Requires CLI |
            | macOS Intel | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-darwin-amd64.tar.gz` | Requires CLI |
            | Windows AMD64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-windows-amd64.zip` | Requires CLI |
            | Windows ARM64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-windows-arm64.zip` | Requires CLI |

            ---

            ### Platform Notes
            - **Linux**: Self-contained binaries with embedded OCR
            - **macOS**: ${{ steps.check-signed.outputs.MACOS_NOTE }}
            - **Windows**: Requires Tesseract from https://github.com/UB-Mannheim/tesseract/wiki

            ### Features
            - Image loading and metadata
            - Color sampling (single & multi-point)
            - Dominant color extraction
            - Image cropping (coordinates and named regions)
            - Distance measurement
            - Grid overlay
            - Edge detection
            - Shape detection (rectangles, circles, lines)
            - Text region detection
            - OCR text extraction

            ### Checksums
            See `checksums.txt` for SHA256 checksums of all files.
