name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # Build Linux AMD64 with CGO (native OCR)
  build-linux-amd64:
    name: Build & Test Linux AMD64
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Install Tesseract dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libtesseract-dev libleptonica-dev

      - name: Download tessdata
        run: ./scripts/ensure-tessdata.sh

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Linux AMD64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            timeout 5 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | \
            grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            timeout 10 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should work with embedded tesseract)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            timeout 30 ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-amd64 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should NOT contain "tesseract not found"
          if echo "$RESPONSE" | grep -q "tesseract not found"; then
            echo "ERROR: OCR should work on Linux with embedded tesseract"
            exit 1
          fi

      - name: Upload Linux AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-linux-amd64
          path: image-tools-mcp-v*-linux-amd64

  # Build Linux ARM64 (cross-compiled, no CGO - uses CLI fallback for OCR)
  # Note: ARM64 runners not available for private repos, so we cross-compile
  build-linux-arm64:
    name: Build Linux ARM64 (cross-compile)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Linux ARM64 binary (cross-compile, no CGO)
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          # Cross-compile without CGO - OCR will use CLI fallback
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64" \
            ./cmd/image-mcp

      - name: Verify binary was created
        run: |
          ls -la image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64
          file image-tools-mcp-v${{ steps.version.outputs.VERSION }}-linux-arm64 | grep -q "ARM aarch64"
          echo "Binary architecture verified as ARM64"

      # Note: Cannot run ARM64 binary on AMD64 runner
      # The binary will be tested by the user on actual ARM64 Linux

      - name: Upload Linux ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-linux-arm64
          path: image-tools-mcp-v*-linux-arm64

  # Build and test macOS AMD64
  build-darwin-amd64:
    name: Build & Test macOS AMD64
    runs-on: macos-15-large  # Intel Mac (macos-13 retired, using macos-15-large for Intel)
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build macOS AMD64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          # Use perl for timeout on macOS (no gtimeout/timeout available)
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            perl -e 'alarm 10; exec @ARGV' ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 | \
            head -100 | grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should return install instructions)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-amd64 2>&1 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should contain "tesseract not found" or "brew install"
          if echo "$RESPONSE" | grep -qE "tesseract not found|brew install"; then
            echo "OK: OCR correctly reports tesseract not installed"
          else
            echo "ERROR: OCR should report tesseract not found on macOS without tesseract"
            exit 1
          fi

      - name: Upload macOS AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-amd64
          path: image-tools-mcp-v*-darwin-amd64

  # Build and test macOS ARM64
  build-darwin-arm64:
    name: Build & Test macOS ARM64
    runs-on: macos-latest  # ARM64 Mac
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build macOS ARM64 binary
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        run: |
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 --version
          ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 --version | grep -q "${{ steps.version.outputs.VERSION }}"

      - name: Smoke test - MCP tools/list
        run: |
          # Use perl for timeout on macOS (no gtimeout/timeout available)
          echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | \
            perl -e 'alarm 10; exec @ARGV' ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 | \
            head -100 | grep -q "image_load"

      - name: Smoke test - Image operations
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"

          # Test image_load
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_load\",\"arguments\":{\"path\":\"${TEST_IMAGE}\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "image_load response: $RESPONSE"
          echo "$RESPONSE" | grep -q width || { echo "ERROR: width not found"; exit 1; }
          echo "OK: image_load returned width"

          # Test image_sample_color
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"image_sample_color\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"x\":10,\"y\":10}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "image_sample_color response: $RESPONSE"
          echo "$RESPONSE" | grep -q hex || { echo "ERROR: hex not found"; exit 1; }
          echo "OK: image_sample_color returned hex"

      - name: Smoke test - OCR (should return install instructions)
        run: |
          TEST_IMAGE="$(pwd)/testdata/simple_diagram.png"
          RESPONSE=$(echo "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"image_ocr_full\",\"arguments\":{\"path\":\"${TEST_IMAGE}\",\"language\":\"eng\"}}}" | \
            ./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-darwin-arm64 2>&1 | head -50)
          echo "OCR Response: $RESPONSE"
          # Should contain "tesseract not found" or "brew install"
          if echo "$RESPONSE" | grep -qE "tesseract not found|brew install"; then
            echo "OK: OCR correctly reports tesseract not installed"
          else
            echo "ERROR: OCR should report tesseract not found on macOS without tesseract"
            exit 1
          fi

      - name: Upload macOS ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-darwin-arm64
          path: image-tools-mcp-v*-darwin-arm64

  # Build and test Windows AMD64
  build-windows-amd64:
    name: Build & Test Windows AMD64
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        shell: bash
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Windows AMD64 binary
        shell: bash
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe" \
            ./cmd/image-mcp

      - name: Smoke test - Version
        shell: pwsh
        run: |
          $output = & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe" --version 2>&1 | Out-String
          Write-Host "Version output: $output"
          if ($output -notlike "*${{ steps.version.outputs.VERSION }}*") {
            throw "Version mismatch: expected ${{ steps.version.outputs.VERSION }} in output"
          }

      - name: Smoke test - MCP tools/list
        shell: pwsh
        run: |
          $response = '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe"
          Write-Host $response
          if ($response -notmatch "image_load") {
            throw "tools/list failed"
          }

      - name: Smoke test - Image operations
        shell: pwsh
        run: |
          $testImage = (Get-Location).Path + "/testdata/simple_diagram.png"
          $testImage = $testImage -replace '\\', '/'

          # Test image_load
          $json = '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"image_load","arguments":{"path":"' + $testImage + '"}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") -join "`n"
          Write-Host "image_load response: $response"
          if ($response -notlike '*"width"*') {
            throw "image_load failed - width not found in response"
          }

          # Test image_sample_color
          $json = '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"image_sample_color","arguments":{"path":"' + $testImage + '","x":10,"y":10}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") -join "`n"
          Write-Host "image_sample_color response: $response"
          if ($response -notlike '*"hex"*') {
            throw "image_sample_color failed - hex not found in response"
          }

      - name: Smoke test - OCR (should return install instructions)
        shell: pwsh
        run: |
          $testImage = (Get-Location).Path + "/testdata/simple_diagram.png"
          $testImage = $testImage -replace '\\', '/'
          $json = '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"image_ocr_full","arguments":{"path":"' + $testImage + '","language":"eng"}}}'
          $response = ($json | & "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-amd64.exe") -join "`n"
          Write-Host "OCR response: $response"
          if ($response -like "*tesseract not found*" -or $response -like "*UB-Mannheim*") {
            Write-Host "OK: OCR correctly reports tesseract not installed"
          } else {
            throw "OCR should report tesseract not found on Windows without tesseract"
          }

      - name: Upload Windows AMD64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-windows-amd64
          path: image-tools-mcp-v*-windows-amd64.exe

  # Build and test Windows ARM64
  build-windows-arm64:
    name: Build & Test Windows ARM64
    runs-on: windows-latest  # Cross-compile, can't run native tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Get version
        id: version
        shell: bash
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Build Windows ARM64 binary
        shell: bash
        run: |
          LDFLAGS="-s -w"
          LDFLAGS="${LDFLAGS} -X 'main.Version=${{ steps.version.outputs.VERSION }}'"
          LDFLAGS="${LDFLAGS} -X 'main.BuildTime=$(date -u +"%Y-%m-%d %H:%M:%S UTC")'"
          LDFLAGS="${LDFLAGS} -X 'main.GitCommit=$(git rev-parse --short HEAD)'"

          CGO_ENABLED=0 GOOS=windows GOARCH=arm64 go build \
            -ldflags="${LDFLAGS}" \
            -o "image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe" \
            ./cmd/image-mcp

      - name: Verify binary was created
        shell: pwsh
        run: |
          if (!(Test-Path "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe")) {
            throw "Binary was not created"
          }
          $size = (Get-Item "./image-tools-mcp-v${{ steps.version.outputs.VERSION }}-windows-arm64.exe").Length
          Write-Host "Binary size: $size bytes"
          if ($size -lt 1000000) {
            throw "Binary seems too small"
          }

      # Note: Cannot run ARM64 binary on AMD64 runner
      # The binary will be tested by the user on actual ARM64 Windows

      - name: Upload Windows ARM64 binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-windows-arm64
          path: image-tools-mcp-v*-windows-arm64.exe

  # Assemble container-tools package (only after all builds pass)
  assemble-package:
    name: Assemble Container Tools Package
    runs-on: ubuntu-latest
    needs:
      - build-linux-amd64
      - build-linux-arm64
      - build-darwin-amd64
      - build-darwin-arm64
      - build-windows-amd64
      - build-windows-arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version
        id: version
        run: echo "VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Download all binaries
        uses: actions/download-artifact@v4
        with:
          path: binaries/
          pattern: binary-*
          merge-multiple: true

      - name: List downloaded binaries
        run: ls -la binaries/

      - name: Create container-tools package structure
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PACKAGE_DIR="image-tools-mcp-v${VERSION}"
          MCP_NAME="image-tools-mcp"

          mkdir -p "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/platforms"

          # Copy all binaries
          cp binaries/* "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/platforms/"
          chmod +x "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/platforms"/*

      - name: Create universal launcher
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PACKAGE_DIR="image-tools-mcp-v${VERSION}"
          MCP_NAME="image-tools-mcp"

          cat > "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/${MCP_NAME}" << 'LAUNCHER'
          #!/usr/bin/env bash
          set -e
          LAUNCHER_VERSION="__VERSION__"
          BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          PLATFORMS_DIR="${BIN_DIR}/platforms"
          MCP_NAME="image-tools-mcp"

          is_container() {
              [ -f /.dockerenv ] && return 0
              [ -n "${CONTAINER}" ] && return 0
              [ -f /proc/1/cgroup ] && grep -qE 'docker|containerd|podman|kubernetes' /proc/1/cgroup 2>/dev/null && return 0
              return 1
          }

          detect_arch() {
              case "$(uname -m)" in
                  x86_64|amd64) echo "amd64" ;;
                  aarch64|arm64) echo "arm64" ;;
                  *) echo "unknown" ;;
              esac
          }

          detect_os() {
              case "$(uname -s | tr '[:upper:]' '[:lower:]')" in
                  darwin) echo "darwin" ;;
                  linux) echo "linux" ;;
                  mingw*|msys*|cygwin*) echo "windows" ;;
                  *) echo "unknown" ;;
              esac
          }

          select_binary() {
              local os=$(detect_os)
              local arch=$(detect_arch)
              local suffix=""
              is_container && os="linux"
              [ "$os" = "windows" ] && suffix=".exe"
              echo "${PLATFORMS_DIR}/${MCP_NAME}-v${LAUNCHER_VERSION}-${os}-${arch}${suffix}"
          }

          exec "$(select_binary)" "$@"
          LAUNCHER

          sed -i "s/__VERSION__/${VERSION}/g" "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/${MCP_NAME}"
          chmod +x "${PACKAGE_DIR}/opt/${MCP_NAME}/bin/${MCP_NAME}"

      - name: Create install script
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PACKAGE_DIR="image-tools-mcp-v${VERSION}"

          cat > "${PACKAGE_DIR}/install.sh" << 'INSTALL'
          #!/bin/bash
          set -e
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          MCP_NAME="image-tools-mcp"
          INSTALL_ROOT="/opt/container-tools"
          MCP_JSON="${INSTALL_ROOT}/etc/mcp.json"

          echo "Installing ${MCP_NAME}..."

          if [ "$EUID" -ne 0 ] && [ ! -w "$INSTALL_ROOT" ]; then
              exec sudo "$0" "$@"
          fi

          mkdir -p "${INSTALL_ROOT}/opt" "${INSTALL_ROOT}/etc"

          if [ -d "${INSTALL_ROOT}/opt/${MCP_NAME}" ]; then
              mv "${INSTALL_ROOT}/opt/${MCP_NAME}" "${INSTALL_ROOT}/opt/${MCP_NAME}.backup.$(date +%Y%m%d%H%M%S)"
          fi

          cp -r "${SCRIPT_DIR}/opt/${MCP_NAME}" "${INSTALL_ROOT}/opt/"
          chmod +x "${INSTALL_ROOT}/opt/${MCP_NAME}/bin/${MCP_NAME}"
          chmod +x "${INSTALL_ROOT}/opt/${MCP_NAME}/bin/platforms"/*

          if [ -f "$MCP_JSON" ]; then
              if command -v jq &> /dev/null; then
                  TEMP_JSON=$(mktemp)
                  jq --arg cmd "${INSTALL_ROOT}/opt/${MCP_NAME}/bin/${MCP_NAME}" \
                     '.mcpServers["image-tools-mcp"] = {"command": $cmd, "args": []}' \
                     "$MCP_JSON" > "$TEMP_JSON"
                  mv "$TEMP_JSON" "$MCP_JSON"
              else
                  echo "WARNING: jq not installed. Manually add image-tools-mcp to ${MCP_JSON}"
              fi
          else
              cat > "$MCP_JSON" << MCPJSON
          {
            "mcpServers": {
              "image-tools-mcp": {
                "command": "${INSTALL_ROOT}/opt/${MCP_NAME}/bin/${MCP_NAME}",
                "args": []
              }
            }
          }
          MCPJSON
          fi

          echo "Installation complete!"
          echo "Test: ${INSTALL_ROOT}/opt/${MCP_NAME}/bin/${MCP_NAME} --version"
          INSTALL

          chmod +x "${PACKAGE_DIR}/install.sh"

      - name: Create README and manifest
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PACKAGE_DIR="image-tools-mcp-v${VERSION}"
          MCP_NAME="image-tools-mcp"

          cat > "${PACKAGE_DIR}/opt/${MCP_NAME}/README.md" << EOF
          # Image Tools MCP v${VERSION}

          MCP server providing image analysis tools for Claude.

          ## Features
          - Image loading and metadata extraction
          - Color sampling (single point and multi-point)
          - Dominant color extraction
          - Image cropping (coordinates and named regions)
          - Distance measurement
          - Grid overlay generation
          - Edge detection
          - Shape detection (rectangles, circles, lines)
          - Text region detection
          - OCR (built-in on Linux; macOS/Windows require Tesseract CLI)

          ## Usage
          /opt/container-tools/opt/image-tools-mcp/bin/image-tools-mcp --version
          EOF

          cat > "${PACKAGE_DIR}/VERSION_MANIFEST.txt" << EOF
          Package: ${MCP_NAME}
          Version: ${VERSION}
          Git Commit: $(git rev-parse --short HEAD)
          Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          Platforms:
            - linux-amd64 (CGO, embedded OCR)
            - linux-arm64 (CGO, embedded OCR)
            - darwin-amd64 (CLI fallback for OCR)
            - darwin-arm64 (CLI fallback for OCR)
            - windows-amd64 (CLI fallback for OCR)
            - windows-arm64 (CLI fallback for OCR)
          EOF

      - name: Create tarball
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          tar -czf "image-tools-mcp-v${VERSION}.tar.gz" "image-tools-mcp-v${VERSION}"

      - name: Upload container-tools package
        uses: actions/upload-artifact@v4
        with:
          name: container-tools-package
          path: image-tools-mcp-v*.tar.gz

      - name: Upload standalone binaries
        uses: actions/upload-artifact@v4
        with:
          name: standalone-binaries
          path: binaries/

  # Sign macOS binaries (optional)
  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: assemble-package
    if: ${{ vars.MACOS_SIGNING_ENABLED == 'true' }}
    steps:
      - name: Download standalone binaries
        uses: actions/download-artifact@v4
        with:
          name: standalone-binaries
          path: binaries/

      - name: Download container-tools package
        uses: actions/download-artifact@v4
        with:
          name: container-tools-package
          path: package/

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          KEYCHAIN_PWD: ${{ secrets.KEYCHAIN_PWD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          echo -n "$MACOS_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH

          security create-keychain -p "$KEYCHAIN_PWD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PWD" $KEYCHAIN_PATH

          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PWD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Sign macOS binaries
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          for binary in binaries/*darwin*; do
            echo "Signing $binary..."
            codesign --force --options runtime \
              --sign "Developer ID Application: ${{ secrets.APPLE_DEVELOPER_NAME }} ($APPLE_TEAM_ID)" \
              --timestamp \
              "$binary"
            codesign --verify --verbose "$binary"
          done

      - name: Notarize binaries
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cd binaries
          for binary in *darwin*; do
            echo "Notarizing $binary..."
            zip "${binary}.zip" "$binary"
            xcrun notarytool submit "${binary}.zip" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_ID_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait
            unzip -o "${binary}.zip"
            xcrun stapler staple "$binary"
            rm "${binary}.zip"
          done

      - name: Rebuild container-tools package with signed binaries
        run: |
          cd package
          tar -xzf *.tar.gz
          rm *.tar.gz
          PACKAGE_DIR=$(ls -d */ | head -1)
          cp ../binaries/*darwin* "${PACKAGE_DIR}/opt/image-tools-mcp/bin/platforms/"
          tar -czf "${PACKAGE_DIR%/}.tar.gz" "$PACKAGE_DIR"

      - name: Upload signed standalone binaries
        uses: actions/upload-artifact@v4
        with:
          name: standalone-binaries-signed
          path: binaries/

      - name: Upload signed container-tools package
        uses: actions/upload-artifact@v4
        with:
          name: container-tools-package-signed
          path: package/*.tar.gz

  # Create GitHub Release (only after all builds and tests pass)
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [assemble-package]
    if: ${{ always() && needs.assemble-package.result == 'success' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download unsigned container-tools package
        uses: actions/download-artifact@v4
        with:
          name: container-tools-package
          path: release/

      - name: Download unsigned standalone binaries
        uses: actions/download-artifact@v4
        with:
          name: standalone-binaries
          path: standalone/

      - name: Download signed container-tools package (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: container-tools-package-signed
          path: release-signed/

      - name: Download signed standalone binaries (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: standalone-binaries-signed
          path: standalone-signed/

      - name: Use signed artifacts if available
        run: |
          if [ -d "release-signed" ] && [ "$(ls -A release-signed 2>/dev/null)" ]; then
            echo "Using signed container-tools package"
            rm -rf release/*
            mv release-signed/* release/
            echo "SIGNED=true" >> $GITHUB_ENV
          else
            echo "Using unsigned container-tools package"
            echo "SIGNED=false" >> $GITHUB_ENV
          fi

          if [ -d "standalone-signed" ] && [ "$(ls -A standalone-signed 2>/dev/null)" ]; then
            echo "Using signed standalone binaries"
            rm -rf standalone/*
            mv standalone-signed/* standalone/
          fi

      - name: Prepare standalone downloads
        run: |
          mkdir -p release/standalone
          cd standalone
          for binary in *; do
            if [[ "$binary" == *.exe ]]; then
              zip "../release/standalone/${binary%.exe}.zip" "$binary"
            else
              tar -czf "../release/standalone/${binary}.tar.gz" "$binary"
            fi
          done

      - name: Generate checksums
        run: |
          cd release
          sha256sum *.tar.gz > checksums.txt
          cd standalone
          sha256sum * >> ../checksums.txt

      - name: Get version
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Check if signed
        id: check-signed
        run: |
          if [ "$SIGNED" = "true" ]; then
            echo "MACOS_NOTE=macOS binaries are signed and notarized." >> $GITHUB_OUTPUT
          else
            echo "MACOS_NOTE=macOS binaries are unsigned. Run \`xattr -d com.apple.quarantine <binary>\` after download." >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Release ${{ steps.version.outputs.VERSION }}
          draft: false
          prerelease: false
          files: |
            release/*.tar.gz
            release/standalone/*
            release/checksums.txt
          body: |
            ## Image Tools MCP ${{ steps.version.outputs.VERSION }}

            MCP server providing image analysis tools for Claude.

            ### OCR Support
            - **Linux (AMD64 & ARM64)**: Built-in OCR with embedded Tesseract - no installation required
            - **macOS & Windows**: Requires Tesseract CLI installation (`brew install tesseract` or download from GitHub)

            ---

            ### Option 1: Container-Tools Package (Recommended)

            Best for users with `/opt/container-tools/` setup (works alongside todo-mcp, etc.)

            ```bash
            # Download and extract
            tar -xzf image-tools-mcp-${{ steps.version.outputs.VERSION }}.tar.gz
            cd image-tools-mcp-${{ steps.version.outputs.VERSION }}

            # Install (creates or merges into /opt/container-tools/)
            ./install.sh

            # Verify
            /opt/container-tools/opt/image-tools-mcp/bin/image-tools-mcp --version
            ```

            ---

            ### Option 2: Standalone Binary

            Download a single binary for your platform:

            | Platform | File | OCR |
            |----------|------|-----|
            | Linux AMD64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-linux-amd64.tar.gz` | Built-in |
            | Linux ARM64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-linux-arm64.tar.gz` | Built-in |
            | macOS Apple Silicon | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-darwin-arm64.tar.gz` | Requires CLI |
            | macOS Intel | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-darwin-amd64.tar.gz` | Requires CLI |
            | Windows AMD64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-windows-amd64.zip` | Requires CLI |
            | Windows ARM64 | `image-tools-mcp-${{ steps.version.outputs.VERSION }}-windows-arm64.zip` | Requires CLI |

            ---

            ### Platform Notes
            - **Linux**: Self-contained binaries with embedded OCR
            - **macOS**: ${{ steps.check-signed.outputs.MACOS_NOTE }}
            - **Windows**: Requires Tesseract from https://github.com/UB-Mannheim/tesseract/wiki

            ### Features
            - Image loading and metadata
            - Color sampling (single & multi-point)
            - Dominant color extraction
            - Image cropping (coordinates and named regions)
            - Distance measurement
            - Grid overlay
            - Edge detection
            - Shape detection (rectangles, circles, lines)
            - Text region detection
            - OCR text extraction

            ### Checksums
            See `checksums.txt` for SHA256 checksums of all files.
